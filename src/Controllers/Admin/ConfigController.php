<?php

declare(strict_types=1);

namespace Engelsystem\Controllers\Admin;

use Engelsystem\Application;
use Engelsystem\Config\Config;
use Engelsystem\Controllers\BaseController;
use Engelsystem\Controllers\HasUserNotifications;
use Engelsystem\Helpers\Authenticator;
use Engelsystem\Helpers\Carbon;
use Engelsystem\Helpers\CarbonDay;
use Engelsystem\Http\Exceptions\HttpForbidden;
use Engelsystem\Http\Exceptions\HttpNotFound;
use Engelsystem\Http\Redirector;
use Engelsystem\Http\Request;
use Engelsystem\Http\Response;
use Engelsystem\Http\UrlGeneratorInterface;
use Engelsystem\Models\EventConfig;
use Illuminate\Support\Str;
use InvalidArgumentException;
use Psr\Log\LoggerInterface;

class ConfigController extends BaseController
{
    use HasUserNotifications;

    protected string $localConfig;

    protected string $passwordPlaceholder = '**********';

    protected array $permissions = [
        'config.edit',
    ];

    protected array $options = [];

    public function __construct(
        protected Response $response,
        protected Config $config,
        protected Redirector $redirect,
        protected UrlGeneratorInterface $url,
        protected LoggerInterface $log,
        protected Authenticator $auth,
        Application $app,
        bool $withAll = false, # Used to get all config options, for example for docs
    ) {
        $this->localConfig = $app->get('path.config') . '/config.local.php';
        $this->options = $this->config->get('config_options', []);
        $this->parseOptions($withAll);
    }

    public function index(): Response
    {
        return $this->redirect->to('/admin/config/' . array_key_first($this->options));
    }

    public function edit(Request $request): Response
    {
        $page = $this->activePage($request);

        return $this->response->withView(
            'admin/config/index',
            [
                'page' => $page,
                'title' => $this->options[$page]['title'],
                'config' => $this->options[$page]['config'],
                'options' => $this->options,
            ]
        );
    }

    public function save(Request $request): Response
    {
        $page = $this->activePage($request);
        $data = $this->validation($page, $request);
        $settings = $this->filterShownSettings($this->options[$page]['config']);
        $localConfigWritable = $this->isFileWritable($this->localConfig);

        $changes = [];
        foreach ($settings as $key => $options) {
            # Request field names with . are parsed with _
            $fieldKey = Str::replace('.', '_', $key);
            $default = $options['default'] ?? null;
            $value = array_key_exists($fieldKey, $data) ? $data[$fieldKey] : $default;

            $value = match ($options['type']) {
                'datetime-local' => $value ? Carbon::createFromDatetime($value) : $value,
                'date' => $value ? CarbonDay::createFromDay($value) : $value,
                'boolean' => !empty($value),
                'number' => (float) $value,
                'password' => $value === $this->passwordPlaceholder ? $this->config->get($key) : $value,
                'select_multi' => is_null($value) ? [] : $value,
                default => $value,
            };

            if ($this->config->get($key) == $value) {
                continue;
            }

            $writeBack = $options['write_back'] ?? false;
            $setValue = $value !== $default && !is_null($value) && $value !== '';
            if ($setValue && !$writeBack) {
                (new EventConfig())
                    ->findOrNew($key)
                    ->setAttribute('name', $key)
                    ->setAttribute('value', $value)
                    ->save();
            } else {
                (new EventConfig())
                    ->whereName($key)
                    ->delete();
            }

            $this->config->set($key, $value);

            if ($writeBack && $localConfigWritable) {
                $oldConfig = [];
                if (file_exists($this->localConfig)) {
                    $oldConfig = include $this->localConfig;
                }
                $config = new Config($oldConfig);
                if ($setValue) {
                    $config->set($key, $value);
                } else {
                    $config->remove($key);
                }
                $configContent =
                    '<?php // !!! Do not edit this file, it will be overwritten on config change !!!' . PHP_EOL .
                    'return ' . var_export($config->get(null), true) . ';' . PHP_EOL;
                file_put_contents($this->localConfig, $configContent);

                // Clear config file from PHPs OPcache to load it on next request
                if (function_exists('opcache_invalidate')) {
                    opcache_invalidate($this->localConfig, true);
                }
            }

            $value = $options['type'] !== 'password' ? $value : $this->passwordPlaceholder;
            $changes[] = sprintf('%s = %s', $key, json_encode($value));
        }

        if ($changes) {
            $this->log->info(
                'Updated {page} configuration: {changes}',
                [
                    'page' => $page,
                    'changes' => implode(', ', $changes),
                ]
            );

            $this->addNotification('config.edit.success');
        }

        return $this->redirect->back();
    }

    public function getOptions(): array
    {
        return $this->options;
    }

    protected function isFileWritable(string $file): bool
    {
        return
            (file_exists($file) && is_writable($file))
            || (!file_exists($file) && is_writable(dirname($file)));
    }

    protected function validation(string $page, Request $request): array
    {
        $rules = [];
        $config = $this->options[$page];
        $settings = $this->filterShownSettings($config['config']);

        // Generate validation rules
        foreach ($settings as $key => $setting) {
            $validation = [];
            $validation[] = empty($setting['required']) ? 'optional' : 'required';
            # Request field names wih . are parsed with _
            $key = Str::replace('.', '_', $key);

            if (
                !empty($setting['validation'])
                // Ignore unchanged passwords
                && !($setting['type'] === 'password' && $request->postData($key) === $this->passwordPlaceholder)
            ) {
                $validation = array_merge($validation, $setting['validation']);
            }

            match ($setting['type']) {
                'string', 'text' => null, // Anything is valid here when optional
                'datetime-local' => $validation[] = 'date_time',
                'date' => $validation[] = 'date',
                'boolean' => $validation[] = 'checked',
                'number' => $validation[] = 'number',
                'url' => $validation[] = 'url',
                'email' => $validation[] = 'email',
                'select' => $validation[] = 'in:' . implode(',', array_keys($setting['data'])),
                'select_multi' => $validation[] = 'array_val|in_many:' . implode(',', array_keys($setting['data'])),
                'password' =>
                    $request->postData($key) !== $this->passwordPlaceholder
                    && (!empty($setting['required']) || $request->postData($key))
                    ? $validation[] = 'length:' . $this->config->get('password_min_length')
                    : null,
                default => throw new InvalidArgumentException(
                    'Type ' . $setting['type'] . ' of ' . $key . ' is not defined'
                ),
            };

            $rules[$key] = implode('|', $validation);
        }

        if (!empty($config['validation']) && is_callable($config['validation'])) {
            return $config['validation']($request, $rules);
        }

        return $this->validate($request, $rules);
    }

    protected function parseOptions(bool $withAll = true): void
    {
        $fromEnv = array_filter($this->config->get('env_config'), fn($a) => !is_null($a));
        $localConfigWritable = $this->isFileWritable($this->localConfig);

        foreach ($this->options as $key => $value) {
            // Add page URLs
            $this->options[$key]['url'] = $this->url->to('/admin/config/' . $key);

            // Configure page translation names
            if (empty($this->options[$key]['title'])) {
                $this->options[$key]['title'] = 'config.' . $key;
            }

            // Define internal validation action
            $internalValidation = 'validate' . Str::ucfirst($key);
            if (method_exists($this, $internalValidation)) {
                // Used until proper dynamic config loading is implemented
                $this->options[$key]['validation'] = [$this, $internalValidation];
            }

            // Iterate over settings
            foreach ($this->options[$key]['config'] as $name => $config) {
                // Ignore hidden options
                if (!empty($config['hidden']) && !$withAll) {
                    unset($this->options[$key]['config'][$name]);
                    continue;
                }

                // Set name for translation
                if (empty($this->options[$key]['config'][$name]['name'])) {
                    $this->options[$key]['config'][$name]['name'] = 'config.' . $name;
                }

                // Configure required icon
                if (!empty($this->options[$key]['config'][$name]['required'])) {
                    $this->options[$key]['config'][$name]['required_icon'] = true;
                }

                // Set ENV name
                if (empty($config['env'])) {
                    $config['env'] = Str::upper($name);
                    $this->options[$key]['config'][$name]['env'] = $config['env'];
                }

                // Configure select values
                if ($config['type'] == 'select' || $config['type'] == 'select_multi') {
                    $data = [];
                    foreach ($config['data'] ?? [] as $dataKey => $dataValue) {
                        if (is_int($dataKey)) {
                            $dataKey = $dataValue;
                            $dataValue = 'config.' . $name . '.select.' . $dataKey;
                        }
                        $data[$dataKey] = $dataValue;
                    }
                    $this->options[$key]['config'][$name]['data'] = $data;
                }

                // Set if overwritten from ENV
                if (isset($fromEnv[$config['env']])) {
                    $this->options[$key]['config'][$name]['in_env'] = true;
                }

                // Set if local config can be written to
                if (!$localConfigWritable && ($config['write_back'] ?? false)) {
                    $this->options[$key]['config'][$name]['writable'] = false;
                }
            }
        }
    }

    protected function filterShownSettings(array $settings): array
    {
        // Ignore values from env
        $settings = array_filter($settings, fn($a) => empty($a['in_env']));
        // Skip if permissions don't match
        return array_filter($settings, fn($a) => empty($a['permission']) || $this->auth->can($a['permission']));
    }

    protected function activePage(Request $request): string
    {
        $page = $request->getAttribute('page');

        if (empty($this->options[$page])) {
            throw new HttpNotFound();
        }

        $permissions = $this->options[$page]['permission'] ?? null;
        if (!empty($permissions) && !$this->auth->can($permissions)) {
            throw new HttpForbidden();
        }

        return $page;
    }

    /**
     * Validation for Event page
     */
    protected function validateEvent(Request $request, array $rules): array
    {
        // Run general validation
        $data = $this->validate($request, $rules);
        $addedRules = [];

        // Ensure event dates are after each other
        $dates = ['buildup_start', 'event_start', 'event_end', 'teardown_end'];
        foreach ($dates as $i => $dateField) {
            if (!$i || !$data[$dateField]) {
                continue;
            }

            foreach (array_slice($dates, 0, $i) as $previousDateField) {
                if (!$data[$previousDateField]) {
                    continue;
                }

                $addedRules[$dateField][] = ['after', $data[$previousDateField], 'true'];
            }
        }

        if (!empty($addedRules)) {
            $this->validate($request, $addedRules);
        }

        return $data;
    }
}
